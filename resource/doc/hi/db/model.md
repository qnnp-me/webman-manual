# तेजी से शुरू करें

webman मॉडल [Eloquent ORM](https://laravel.com/docs/7.x/eloquent) पर आधारित है। प्रत्येक डेटाबेस तालिका के लिए एक "मॉडल" है जो उस तालिका के साथ इंटरेक्ट करने के लिए होता है। आप मॉडल का उपयोग करके डेटा तालिका में से डेटा क्वेरी कर सकते हैं, साथ ही नए रिकॉर्ड तालिका में डाल सकते हैं।

शुरू करने से पहले, कृपया सुनिश्चित करें कि `config/database.php` में डेटाबेस कनेक्शन को कॉन्फ़िगर किया गया है।

> ध्यान दें: Eloquent ORM मॉडल ऑब्जेवर्स का समर्थन करने के लिए `composer require "illuminate/events"` [उदाहरण](#मॉडल-ऑब्जेवर्स)

## उदाहरण
```php
<?php
namespace app\model;

use support\Model;

class User extends Model
{
    /**
     * मॉडल के साथ संबंधित टेबल का नाम
     *
     * @var string
     */
    protected $table = 'user';

    /**
     * प्राथमिक कुंजी को पुनर्निर्धारित करना, डिफ़ॉल्ट रूप से id होता है
     *
     * @var string
     */
    protected $primaryKey = 'uid';

    /**
     * क्या स्वचालित रूप से समय चिन्हित रखना है
     *
     * @var bool
     */
    public $timestamps = false;
}
```

## टेबल का नाम
आप अपनी पसंद की डेटा तालिका को संदर्भित करने के लिए मॉडल पर table गुण को परिभाषित करके उपयुक्त डेटा तालिका को निर्दिष्ट कर सकते हैं।
```php
class User extends Model
{
    /**
     * मॉडल के साथ संबंधित टेबल का नाम
     *
     * @var string
     */
    protected $table = 'user';
}
```

## प्राथमिक कुंजी
Eloquent यह भी मान लेता है कि प्रत्येक डेटा तालिका में एक 'id' नामक प्राथमिक कुंजी स्तंभ होगा। आप कायापालित $primaryKey संरक्षित गुण को दोबारा लिखने के लिए पुनर्विवरण कर सकते हैं।
```php
class User extends Model
{
    /**
     * प्राथमिक कुंजी को पुनर्निर्धारित करना, डिफ़ॉल्ट रूप से id होता है
     *
     * @var string
     */
    protected $primaryKey = 'uid';
}
```

Eloquent मानता है कि प्राथमिक कुंजी एक स्वचालित वृद्धि वाला पूर्णांक मान है, इसका अर्थ है कि डिफ़ॉल्ट रूप में प्राथमिक कुंजी अपने आप को int प्रकार में बदल दिया जाएगा। यदि आप नहीं-वृद्धि या गैर-संख्यात्मक प्राथमिक कुंजी का उपयोग करना चाहते हैं तो आपको सार्वजनिक $incrementing गुण को false सेट करना होगा
```php
class User extends Model
{
    /**
     * मॉडल प्राथमिक कुंजी को वृद्धि करने की संकेत देती है
     *
     * @var bool
     */
    public $incrementing = false;
}
```

यदि आपकी प्राथमिक कुंजी एक पूर्णांक नहीं है, तो आपको मॉडल पर संरक्षित $keyType गुण को 'string' सेट करना होगा:
```php
class User extends Model
{
    /**
     * स्वचालित वृद्धि आईडी के "प्रकार"।
     *
     * @var string
     */
    protected $keyType = 'string';
}
```

## समय चिन्ह
डिफ़ॉल्ट रूप से, Eloquent उम्मीद करता है कि आपकी डेटा तालिका में created_at और updated_at मौजूद होगा। अगर आप चाहते हैं कि Eloquent खुद से इन दो स्तंभों को स्वचालित रूप से प्रबंधित न करे, तो कृपया मॉडल में $timestamps गुण को false सेट करें:
```php
class User extends Model
{
    /**
     * समय चिन्ह की स्वचालित रखने की संकेत देती है
     *
     * @var bool
     */
    public $timestamps = false;
}
```
यदि आपको समय चिन्ह का स्वचालित तारीख स्थानांतरण का प्रारूप कस्टमाइज़ करने की आवश्यकता है, तो कृपया अपने मॉडल में $dateFormat गुण सेट करें। यह गुण तिथि गुण को डेटाबेस में संग्रहित करने का तरीका निर्धारित करता है, साथ ही इसे मॉडल को एरे या JSON के प्रारूप में सीरियलाइज़ करता है:
```php
class User extends Model
{
    /**
     * समय चिन्ह संग्रहण प्रारूप
     *
     * @var string
     */
    protected $dateFormat = 'U';
}
```

अगर आपको समय चिन्ह के क्षेत्र के संग्रहण का नाम कस्टमाइज़ करने की आवश्यकता है, तो आप मॉडल में CREATED_AT और UPDATED_AT स्थायी कीमतों को प्राप्त करने के लिए मान संलग्न कर सकते हैं:
```php
class User extends Model
{
    const CREATED_AT = 'creation_date';
    const UPDATED_AT = 'last_update';
}
```

## डेटाबेस कनेक्शन
डिफ़ॉल्ट रूप से, Eloquent मॉडल आपके ऐप्लिकेशन को निर्धारित डेटाबेस कनेक्शन का उपयोग करेगा। अगर आप मॉडल को एक विभिन्न कनेक्शन को संदर्भित करना चाहते हैं, तो $connection गुण को सेट करें:
```php
class User extends Model
{
    /**
     * मॉडल का कनेक्शन नाम
     *
     * @var string
     */
    protected $connection = 'connection-name';
}
```

## डिफ़ॉल्ट गुणमत्ता मानें
यदि आप किसी मॉडल के लिए कुछ गुणों की मूल अवधारणा परिभाषित करना चाहते हैं, तो आप मॉडल पर $attributes गुण को परिभाषित कर सकते हैं:
```php
class User extends Model
{
    /**
     * मॉडल की मूल गुणमत्ता मानें।
     *
     * @var array
     */
    protected $attributes = [
        'delayed' => false,
    ];
}
```

## मॉडल खोज
मॉडल और उस से संबंधित डेटाबेस तालिका को बनाने के बाद, आप डेटाबेस से डाटा क्वेरी कर सकते हैं। प्रत्येक Eloquent मॉडल को एक शक्तिशाली क्वेरी निर्माता के रूप में देखा जा सकता है, जिसके माध्यम से आप तेजी से उससे संबंधित डेटा तालिका को क्वेरी कर सकते हैं। उदाहरण के लिए:
```php
$users = app\model\User::all();

foreach ($users as $user) {
    echo $user->name;
}
```
> सुझाव: क्योंकि Eloquent मॉडल भी एक क्वेरी निर्माता है, इसलिए आपको [क्वेरी निर्माता](queries.md) में उपलब्ध सभी विधियों की जांच करनी चाहिए। आप Eloquent कुएरी में इन विधियों का उपयोग कर सकते हैं।

## अतिरिक्त प्रतिबंध
Eloquent की सभी विधियों का उपयोग करते हुए all विधि मॉडल के सभी परिणाम वापस करेगी। क्योंकि प्रत्येक Eloquent मॉडल एक क्वेरी निर्माता का कार्य करता है, इसलिए आप क्वेरी शर्तों को जोड़ सकते हैं, और फिर get विधि का उपयोग करके क्वेरी के परिणाम प्राप्त कर सकते हैं:
```php
$users = app\model\User::where('name', 'like', '%tom')
               ->orderBy('uid', 'desc')
               ->limit(10)
               ->get();
```
## मॉडल को रीलोड करें
आप फ्रेश और रिफ्रेश मेथड का उपयोग करके मॉडल को रीलोड कर सकते हैं। फ्रेश मेथड डेटाबेस से मॉडल को पुनः प्राप्त करता है। मौजूदा मॉडल इंस्टेंस पर कोई प्रभाव नहीं पड़ता:
```php
$user = app\model\User::where('name', 'tom')->first();

$fresh_user = $user->fresh();
```

रिफ्रेश मेथड नए डेटाबेस डेटा का उपयोग करके मौजूदा मॉडल को फिर से मूल्यांकित करता है। साथ ही, पहले से लोड किए गए संबंधों को भी फिर से लोड करता है:
```php
$user = app\model\User::where('name', 'tom')->first();

$user->name = 'jerry';

$user = $user->fresh();

$user->name; // "tom"
```


## संग्रह
Eloquent की सभी और get मेथड से एक से अधिक परिणाम प्राप्त किया जा सकता है, जो एक `Illuminate\Database\Eloquent\Collection` इंस्टेंस वापस करता है। `Collection` क्लास प्रशासनिक फ़ंक्शन्स प्रदान करता है जो Eloquent परिणामों का निपटान करने में मदद करता है:
```php
$users = $users->reject(function ($user) {
    return $user->disabled;
});
```


## कर्सर का उपयोग
कर्सर मेथड आपको डेटाबेस को ट्रावर्स करने के लिए योग्यता देता है, यह केवल एक बार पूर्वावलोकन करता है। बड़े मात्रा में डेटा को निपटाते समय, कर्सर मेथड मेमोरी के इस्तेमाल को काफ़ी कम कर सकता है:
```php
foreach (app\model\User::where('sex', 1')->cursor() as $user) {
    //
}
```

कर्सर `Illuminate\Support\LazyCollection` इंस्टेंस वापस करता है। [Lazy collections](https://laravel.com/docs/7.x/collections#lazy-collections) आपको Laravel संग्रह में अधिकांश संग्रह के फ़ंक्शन का उपयोग करने देता है, और प्रत्येक बार केवल एक मॉडल को मेमोरी में लोड करता है:
```php
$users = app\model\User::cursor()->filter(function ($user) {
    return $user->id > 500;
});

foreach ($users as $user) {
    echo $user->id;
}
```

## सबक्यूरी सबक्यूरी
Eloquent उच्च स्तरीय सबक्यूरी समर्थन प्रदान करता है, आप एक ही क्यूरी वाले फ़ंक्शन का उपयोग करके संबंधित तालिका से जानकारी निकाल सकते हैं। उदाहरण के लिए, मान लें हमारे पास एक डेस्टिनेशन तालिका destinations है और एक डेस्टिनेशन तक उड़ान तालिका flights है। उड़ान तालिका में एक arrival_at फ़ील्ड होता है, जो प्रदर्शित करता है कि उड़ान डेस्टिनेशन पर कब पहुंचेगी।

Subquery की सुविधा द्वारा प्रदान किए गए select और addSelect मेथड का उपयोग करते हुए, हम सिर्फ़ एक ही क्यूरी लेटे हुए सभी destinations को प्राप्त कर सकते हैं, और प्रत्येक डेस्टिनेशन के लिए आखिरी उड़ान का नाम:
```php
use app\model\Destination;
use app\model\Flight;

return Destination::addSelect(['last_flight' => Flight::select('name')
    ->whereColumn('destination_id', 'destinations.id')
    ->orderBy('arrived_at', 'desc')
    ->limit(1)
])->get();
```

## Subquery के आधार पर क्रमवारी
इसके अलावा, क्वेरी बिल्डर का orderBy फ़ंक्शन भी Subquery का समर्थन करता है। हम इस सुविधा का उपयोग करके सभी destinations को उस समय के आधार पर क्रमवारी देने के लिए कर सकते हैं, जब आखिरी उड़ान डेस्तिनेशन पर पहुंचेगी। इस तरह, यह डेटाबेस पर केवल एक ही क्यूरी को चलाएगा:
```php
return Destination::orderByDesc(
    Flight::select('arrived_at')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderBy('arrived_at', 'desc')
        ->limit(1)
)->get();
```

## एकल मॉडल / संग्रह प्राप्त करें
अपेक्षाया डेटाबेस से सभी रिकॉर्ड प्राप्त करने के बजाय, आप find, first या firstWhere मेथड का उपयोग करके एकल रिकॉर्ड प्राप्त कर सकते हैं। ये मेथड फ़ंक्शन नहीं मॉडल इंस्टेंस वापस करते हैं।
```php
// प्राइमरी की माध्यम से मॉडल खोजें...
$flight = app\model\Flight::find(1);

// क्वेरी शर्त को मान्य करने वाला पहला मॉडल खोजें...
$flight = app\model\Flight::where('active', 1)->first();

// क्वेरी शर्त को मान्य करने वाला पहला मॉडल की शीघ्र अवस्था खोजें...
$flight = app\model\Flight::firstWhere('active', 1);
```

आप find मेथड का प्राइमरी की माध्यम से मॉडल खोजने के लिए प्राइमरी एरे का उपयोग कर सकते हैं, जो मिलान रिकॉर्ड का संग्रह वापस करेगा:
```php
$flights = app\model\Flight::find([1, 2, 3]);
```

कभी-कभी आपको सिर्फ़ परिणाम की पहली रिकॉर्ड को खोजना है, लेकिन मान नहीं मिलता है। firstOr मेथड नतीजे मिलते ही पहले नतीजे को वापस करेगा, और अगर कोई परिणाम नहीं मिलता है, तो दिए गए कॉलबैक को निष्पादित करेगा। कॉलबैक की वापसी मूल्य firstOr मेथड की वापसी मूल्य के रूप में होगी:
```php
$model = app\model\Flight::where('legs', '>', 100)->firstOr(function () {
        // ...
});
```
firstOr मेथड यहाँ समानार्थी फ़ील्ड श्रृंखला का उपयोग करता है:
```php
$model = app\model\Flight::where('legs', '>', 100)
            ->firstOr(['id', 'legs'], function () {
                // ...
            });
```

## "नहीं पाया गया" अपवाद
कभी-कभी आप चाहेंगे कि मॉडल को नहीं मिलने पर अपवाद फेंका जाए। यह नियंत्रक और मार्ग में बहुत उपयोगी होता है। findOrFail और firstOrFail मेथड क्वेरी के पहले रिकॉर्ड का अनुसंधान करेंगे, और यदि कोई नतीजा नहीं मिलता है, तो Illuminate\Database\Eloquent\ModelNotFoundException अपवाद फेंकेंगे:
```php
$model = app\model\Flight::findOrFail(1);
$model = app\model\Flight::where('legs', '>', 100)->firstOrFail();
```


## संग्रह प्राप्त करना
आप निर्माण क्रियाकलाप वाले परिणामों को निपटान करने के लिए क्वेरी निर्माणकर्ता द्वारा प्रदान की गई count, sum और max विधियों, और अन्य संग्रह फ़ंक्शन भी उपयोग कर सकते हैं। ये विधियां केवल मॉडल इंस्टेंस की बजाय उचित संकेत मानक वापस करती हैं:
```php
$count = app\model\Flight::where('active', 1)->count();

$max = app\model\Flight::where('active', 1)->max('price');
```
## इनसर्ट
डेटाबेस में नया रिकॉर्ड जोड़ने के लिए, पहले नया मॉडल उदाहरण बनाएं, उस उदाहरण को गुण सेट करें, और फिर सेवा विधि को बुलाएं:

```php
<?php

namespace app\controller;

use app\model\User;
use support\Request;
use support\Response;

class FooController
{
    /**
     * उपयोगकर्ता तालिका में एक नया रिकॉर्ड जोड़ें
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // अनुरोध सत्यापन करें

        $user = new User;

        $user->name = $request->get('name');

        $user->save();
    }
}
```

created_at और updated_at टाइमस्टैम्प स्वचालित रूप से सेट हो जाएंगे (जब मॉडल में $timestamps गुणसूत्र सत्य होता है), हाथ से मूल्य प्रदान करने की आवश्यकता नहीं है।

## अपडेट
सेवा विधि का उपयोग डेटाबेस में पहले से मौजूद मॉडल को अपडेट करने के लिए किया जा सकता है। मॉडल को अपडेट करने के लिए, आपको पहले उसे प्राप्त करना होगा, अपडेट करने के लिए गुणों को सेट करना होगा, और फिर सेवा विधि को बुलाना होगा। इसी तरह, updated_at टाइमस्टैम्प स्वचालित रूप से अपडेट हो जाएगा, इसलिए हाथ से मूल्य देने की आवश्यकता नहीं है:

```php
$user = app\model\User::find(1);
$user->name = 'जेरी';
$user->save();
```

## बैच अपडेट
```php
app\model\User::where('uid', '>', 10)
          ->update(['name' => 'टॉम']);
```

## गुण परिवर्तन की जांच
Eloquent isDirty, isClean और wasChanged विधियाँ प्रदान करता है, जिनका उपयोग मॉडल की आंतरिक स्थिति की जांच करने के लिए किया जा सकता है और यह निर्धारित करने के लिए कि उसके गुण मूल से लोड करने के बाद कैसे बदल गए हैं। isDirty विधि मूल्य पता लगाता है कि क्या किसी गुण को मूल से बदल दिया गया है। आप विशिष्ट गुण का पता लगाने के लिए विशिष्ट गुण का नाम पास कर सकते हैं। isClean विधि isDirty के विपरीत है, यह भी वैकल्पिक गुण पैरामीटर स्वीकार करता है।
```php
$user = User::create([
    'first_name' => 'टेलर',
    'last_name' => 'ओटवेल',
    'title' => 'डेवलपर',
]);

$user->title = 'पेंटर';

$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false

$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true

$user->save();

$user->isDirty(); // false
$user->isClean(); // true
```
wasChanged विधि वर्तमान अनुरोध चक्र के दौरान अंतिम सहेजे गए मॉडल को देखती है कि क्या इसके कोई गुण बदल गए हैं। आप विशिष्ट गुण को देखने के लिए गुण का नाम भी पास कर सकते हैं:
```php
$user = User::create([
    'first_name' => 'टेलर',
    'last_name' => 'ओटवेल',
    'title' => 'डेवलपर',
]);

$user->title = 'पेंटर';
$user->save();

$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged('first_name'); // false
```
## बैच देना
आप नए मॉडल को बचाव करने के लिए create विधि का उपयोग कर सकते हैं। यह विधि मॉडल उदाहरण लौटाएगी। हालांकि, उपयोग से पहले आपको उन गुणों को निर्धारित करना होगा जो fillable या guarded गुणों पर होते हैं, क्योंकि सभी एलोक्वेंट मॉडल डिफ़ॉल्ट रूप से बैच देने की अनुमति नहीं देते।

जब उपयोक्ता अनपेक्षित एचटीटीपी पैरामीटर प्रेषित करते हैं और यह पैरामीटर उन गुणों को बदल देता है जो आपको डेटाबेस में बदलने की आवश्यकता नहीं है, तो बैच देने की विफलता हो सकती है। उदाहरण के लिए: हानिकारक उपयोक्ता संभावित रूप से एचटीटीपी अनुरोध के माध्यम से is_admin पैरामीटर प्लान करता है, और फिर इसे create विधि को पास करता है, यह कार्रवाई उपयोक्ता को खुद को व्यवस्थापक बनाने की अनुमति दे सकती है।

तो, शुरू करने से पहले, आपको निर्धारित करना चाहिए कि मॉडल पर कौन-कौन से गुणों को बैच देने की अनुमति है। आप एलोक्वेंट मॉडल पर $fillable गुण का उपयोग करके इसे कर सकते हैं। उदाहरण के लिए: Flight मॉडल के लिए करने के योग्य सारे गुणों को बैच देने की अनुमति देने के लिए नाम गुण को फिल्ल करने की अनुमति देने के लिए:
```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * पूर्वनिर्धारित की गई गुण
     *
     * @var array
     */
    protected $fillable = ['नाम'];
}

```
एक बार जब आप निर्धारित कर दिया है कि कौन-कौन से गुण बैच देने की अनुमति है, तो create विधि का उपयोग नया डेटा डेटाबेस में डालने के लिए किया जा सकता है। create विधि सहेजी गई मॉडल उदाहरण लौटाएगी:
```php
$flight = app\model\Flight::create(['name' => 'फ्लाइट 10']);
```
अगर आपके पास पहले से मॉडल उदाहरण है, तो आप fill विधि को गुण को भरने के लिए एक सरणी पास कर सकते हैं:
```php
$flight->fill(['name' => 'फ्लाइट 22']);
```

$fillable को बैच देने का "सफेद सूची" के रूप में समझा जा सकता है, आप गुर्दियान के गुण का उपयोग करके भी कर सकते हैं। गुर्दियान गुण वह गुण संग्रह होता है जिसे यौथ्य की अनुमति नहीं है। यानी, गुर्दियान गुण कार्यान्वयन से "काली सूची" के रूप में अधिक संभवना होती है। ध्यान दें: आप केवल $fillable या $guarded दोनों में से एक ही उपयोग कर सकते हैं, उन्हें एक साथ उपयोग नहीं कर सकते। नीचे दिए गए उदाहरण में, कीमत गुण के बाहर के सभी गुणों को बैच देने की अनुमति नहीं है:
```php
<?php

namespace app\model;

use support\Model;

class Flight extends Model
{
    /**
     * बैच देने की अनुमति नहीं देने वाले गुण
     *
     * @var array
     */
    protected $guarded = ['मूल्य'];
}
```
अगर आप सभी गुणों को बैच देने की अनुमति देना चाहते हैं, तो आप $guarded को एक खाली सरणी के रूप में परिभाषित कर सकते हैं:
```php
/**
 * बैच देने की अनुमति नहीं देने वाले गुण
 *
 * @var array
 */
protected $guarded = [];
```
अन्य बनाने के तरीके
firstOrCreate/ firstOrNew
यहाँ दो विधियाँ हैं जो आपको बचत में करने के लिए उपयोग कर सकते हैं: firstOrCreate और firstOrNew। firstOrCreate विधि द्वारा दिए गए कुंजी / मानों के माध्यम से डेटाबेस में मॉडल डेटा का मेल खाता है। अगर डेटाबेस में मॉडल नहीं मिलता है तो पहले पैरामीटर की संपत्तियों के साथ और वैकल्पिक दूसरे पैरामीटर की संपत्तियों के साथ रेकॉर्ड डाल देगा।

फर्स्टअरन्यू विधि firstOrCreate विधि की तरह प्रयास करेगी दिए गए गुणों के माध्यम से डेटाबेस में रेकॉर्ड ढूंढ़ने का। हालांकि, अगर firstOrNew विधि कोई मॉडल नहीं मिलता है, तो एक नया मॉडल उदाहरण देगा। ध्यान दें कि firstOrNew वापसी वाला मॉडल उदाहरण डाटाबेस में सहेजा नहीं गया है, आपको सहेजने के लिए सेव विधि को मैन्युअल रूप से बुलाना होगा:

```php
// नाम पर फ्लाइट खोजें, अगर नहीं मिलता है तो बनाएं...
$flight = app\model\Flight::firstOrCreate(['name' => 'Flight 10']);

// नाम पर फ्लाइट खोजें, या नाम और देरी गुण और पहुंच समय गुण का उपयोग करके बनाएं...
$flight = app\model\Flight::firstOrCreate(
    ['name' => 'Flight 10'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

// नाम पर फ्लाइट खोजें, नहीं मिलता है तो एक उदाहरण बनाएं...
$flight = app\model\Flight::firstOrNew(['name' => 'Flight 10']);

// नाम पर फ्लाइट खोजें, या नाम और देरी गुण और पहुंच समय गुण के साथ एक मॉडल उदाहरण बनाएं...
$flight = app\model\Flight::firstOrNew(
    ['name' => 'Flight 10'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

```

आपको शायद एक मौत को अपडेट करने या अगर नहीं है तो एक नया मॉडल बनाने की आवश्यकता हो सकती है। इसलिए updateOrCreate विधि से एक चरण में कर सकते हैं। firstOrCreate विधि के समान, updateOrCreate परिस्थितियों को स्थायी करता है, ठीक वैसे ही कोई छंद के कॉल करने की आवश्यकता नहीं है:

```php
// यदि ऑकलैंड से सैंट डिएगो के लिए फ्लाइट है, तो मूल्य को 99 डॉलर किया जाता है।
// अगर मॉडल मिला नहीं है तो एक बनाएं।
$flight = app\model\Flight::updateOrCreate(
    ['departure' => 'Oakland', 'destination' => 'San Diego'],
    ['price' => 99, 'discounted' => 1]
);

```

## मॉडल हटाना
मॉडल उदाहरण पर हटाने के लिए delete विधि को कॉल कर सकते हैं:
```php
$flight = app\model\Flight::find(1);
$flight->delete();
```

## प्राथमिक कुंजी के माध्यम से मॉडल हटाने
```php
app\model\Flight::destroy(1);

app\model\Flight::destroy(1, 2, 3);

app\model\Flight::destroy([1, 2, 3]);

app\model\Flight::destroy(collect([1, 2, 3]));

```

## क्वेरी के माध्यम से मॉडल हटाना
```php
$deletedRows = app\model\Flight::where('active', 0)->delete();
```

## मॉडल की प्रतिलिपि
आप replicate विधि का उपयोग करके डेटाबेस में सहेजा नहीं गया एक नया उदाहरण की प्रतिलिपि बना सकते हैं, जब मॉडल उदाहरण अनेक समान गुणों को साझा करते हैं, तो यह विधि बहुत उपयुक्त होती है।
```php
$shipping = App\Address::create([
    'type' => 'shipping',
    'line_1' => '123 Example Street',
    'city' => 'Victorville',
    'state' => 'CA',
    'postcode' => '90001',
]);

$billing = $shipping->replicate()->fill([
    'type' => 'billing'
]);

$billing->save();

```

## मॉडल तुलना
कभी-कभी आपको दो मॉडलों को "समान" होने का निर्धारण करने की आवश्यकता हो सकती है। is विधि का उपयोग दो मॉडलों के प्राथमिक कुंजी, तालिका और डेटाबेस कनेक्शन के बारे में त्वरित जांच करने के लिए किया जा सकता है:
```php
if ($post->is($anotherPost)) {
    //
}
```


## मॉडल नेतृत्वीय
[Laravel में मॉडल घटनाएं और अवलोककर्ता  के लेख](https://learnku.com/articles/6657/model-events-and-observer-in-laravel) का उपयोग करें

ध्यान दें: Eloquent ORM मॉडल नेतृत्वीय का समर्थन करने के लिए अतिरिक्त आयात की आवश्यकता है composer require "illuminate/events"

```php
<?php
namespace app\model;

use support\Model;
use app\observer\UserObserver;

class User extends Model
{
    public static function boot()
    {
        parent::boot();
        static::observe(UserObserver::class);
    }
}
```
